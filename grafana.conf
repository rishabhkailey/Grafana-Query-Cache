proxy_cache_path ${CACHE_DIRECTORY} levels=1:2 keys_zone=grafana_query_cache:10m inactive=${MAX_INACTIVE_TIME} max_size=${MAX_CACHE_SIZE};
log_format log_including_cache_key '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for" \'"$upstream_cache_status" "$generated_cache_key" "$cache_access_denied"\'';

upstream grafana_server {
    server ${GRAFANA_HOST};
}

map $upstream_cache_status $cache_found {
    HIT     1;
    default 0; 
}

# default empty string
geo $remote_addr $debug { 
    ${DEBUG_IP_CADR}       "yes"; 
    # default takes precedence when DEBUG_IP_CADR is set to 0.0.0.0/0 
    # default                 "";
}

# if generated_cache_key is empty then no cache
map $generated_cache_key  $empty_cache_key { 
    ""          1;
    default     0;
}

# this is required to proxy Grafana Live WebSocket connections.
map $http_upgrade $connection_upgrade {
  default   upgrade;
  ''        close;
}

map $generated_cache_key $cache_key {
    ''      '';
    default 'v${CACHE_VERSION}_$generated_cache_key';
}

server {
    listen                  ${LISTEN} default_server;
    server_name             ${SERVER_NAME};
    client_max_body_size    ${CLIENT_MAX_BODY_SIZE};

    set $acceptable_time_delta_seconds          $ACCEPTABLE_TIME_DELTA_SECONDS;
    set $acceptable_time_range_delta_seconds    $ACCEPTABLE_TIME_RANGE_DELTA_SECONDS;
    set $acceptable_max_points_delta            $ACCEPTABLE_MAX_POINTS_DELTA;


    ${SSL_CONFIG}
    # https://github.com/openresty/openresty/blob/master/t/001-resolver.t#L20
    # https://github.com/openresty/lua-resty-redis/issues/159#issuecomment-460101005
    resolver local=on;
    location /api/ds/query {
        access_log          /usr/local/openresty/nginx/logs/access.log log_including_cache_key;

        proxy_cache         grafana_query_cache;
        proxy_cache_methods POST;
        proxy_cache_valid   200 ${CACHE_EXPIRE_TIME};
        
        proxy_cache_min_uses ${MIN_REQUEST_COUNT};

        # to prevent multiple requests going to origin server immediate after cache expiring
        proxy_cache_lock            on;
        proxy_cache_lock_timeout    10s;

        # return old cached response if the cache is updating or proxy_cache_lock_timeout is reached
        proxy_cache_use_stale   updating    timeout;
        proxy_cache_revalidate  off;

        # debug headers will only work if host = localhost
        if ($debug = "yes") {
            add_header      X-Cache-Status          $upstream_cache_status;        
            add_header      X-Cache-Key             $cache_key;
            add_header      X-Cache-Access-Denied   $cache_access_denied;
        }

        # for testing read request body from file
        # client_body_in_file_only clean;

        set $generated_cache_key              "";
        set $cache_access_denied    0;
        
        rewrite_by_lua_block {
            function get_cache_key()
                local grafana_request = require "grafana_request"
                local body_data = get_body_data()
                if not body_data then
                    -- no caching
                    ngx.var.generated_cache_key = ""
                    return
                end
                local generated_cache_key, datasource_uids = grafana_request.get_cache_key_and_datasource_uids(body_data, tonumber(ngx.var.acceptable_time_delta_seconds), tonumber(ngx.var.acceptable_time_range_delta_seconds), tonumber(ngx.var.acceptable_max_points_delta))
                if type(generated_cache_key) ~= "string" or string.len(generated_cache_key) == 0 or type(datasource_uids) ~= "table" or #datasource_uids == 0 then
                    ngx.log(ngx.DEBUG, type(generated_cache_key), type(datasource_uids))
                    error("empty cache key or empty datasource_uids table")
                    return
                end

                local cookie_header = ngx.req.get_headers()["Cookie"]

                if not cookie_header then
                    cookie_header = ""
                end
                local authorization_header = ngx.req.get_headers()["Authorization"]
                if not authorization_header then
                    authorization_header = ""
                end

                local user_access = check_user_access("${GRAFANA_SCHEME}://${GRAFANA_HOST}", datasource_uids, cookie_header, authorization_header)
                if user_access == false then
                    ngx.var.cache_access_denied = 1
                end

                ngx.var.generated_cache_key = generated_cache_key
                ngx.log(ngx.DEBUG, "cache key: ", ngx.var.generated_cache_key)
            end

            function error_handler(err) 
                ngx.log(ngx.STDERR, "failed to generate cache key: ", err)
                ngx.var.generated_cache_key = ""
            end

            function get_body_data() 
                ngx.req.read_body() 
                local body_data = ngx.req.get_body_data()
                if not body_data then
                    -- try reading body file
                    local body_file = ngx.req.get_body_file()
                    if body_file then
                        -- we are not checking the body size before reading it into memory
                        -- we should set max request size in nginx config
                        -- todo document above somewhere
                        local file = io.open(body_file, "rb")
                        if not file then
                            ngx.log(ngx.STDERR, "unable to open request file")
                            return nil
                        end
                        body_data = file:read("*all")
                    else
                        ngx.log(ngx.STDERR, "unable to get request body")
                        return nil
                    end
                end
                return body_data
            end

            function entrypoint() 
                local generated_cache_key = get_cache_key()
                if string.len(generated_cache_key) == 0 then
                    error("empty cache key")
                end
                
            end

            xpcall(get_cache_key, error_handler)
        }

        proxy_cache_key     $cache_key;
        proxy_no_cache      $empty_cache_key;
        proxy_cache_bypass  $cache_access_denied;

        proxy_set_header    Host    $http_host;
        proxy_pass          ${GRAFANA_SCHEME}://grafana_server;
        
        # https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_headers
        # cache-control header is set to no-store by grafana which avoids caching
        proxy_ignore_headers    Cache-Control;
        proxy_hide_header       Cache-Control;
        proxy_hide_header       Server;
        add_header              Cache-Control   "private, max-age=3600";
    }

    location / {
        proxy_set_header Host $http_host;
        proxy_pass  ${GRAFANA_SCHEME}://grafana_server;
    }

    # Proxy Grafana Live WebSocket connections.
    location /api/live/ {
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_set_header Host $http_host;
        proxy_pass http://grafana_server;
    }

}